/**
 * Cloudflare Worker für die Integration mit Airtable.
 *
 * Dieser Worker ist robust gegen Fehler beim Abrufen von Airtable-Daten
 * und dient als API für die Web-App. Er hat zwei Hauptfunktionen:
 * 1. Ruft alle benötigten Daten für einen Teilnehmer ab und liefert sie im
 * korrekten Format an die App.
 * 2. Speichert die Monatsverfügbarkeit, die von der App übermittelt wird,
 * im entsprechenden Airtable-Feld.
 *
 * Wichtige Hinweise:
 * 1. AIRTABLE_API_KEY und AIRTABLE_BASE_ID müssen als Secrets in den Worker-Einstellungen hinterlegt sein.
 * 2. Die Namen der Airtable-Felder im Worker-Code müssen exakt mit Ihren Airtable-Spaltennamen übereinstimmen.
 */

// Haupt-Worker-Modul
export default {
    async fetch(request, env, ctx) {
        console.log(`[Worker Start] Anfrage erhalten: ${request.method} ${request.url}`);

        const url = new URL(request.url);
        const path = url.pathname;

        const defaultHeaders = {
            'Access-Control-Allow-Origin': 'https://www.burnouthilfe.org',
            'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
            'Access-Control-Allow-Headers': 'Content-Type, Authorization',
            'Access-Control-Max-Age': '86400',
        };

        if (request.method === 'OPTIONS') {
            console.log("[Worker] OPTIONS Anfrage erkannt, sendet CORS Preflight Header.");
            return new Response(null, { status: 204, headers: defaultHeaders });
        }

        // Helper function for robust Airtable API calls
        const fetchAirtable = async (endpoint, options = {}) => {
            const fetchResponse = await fetch(endpoint, options);
            if (!fetchResponse.ok) {
                const errorBody = await fetchResponse.text();
                console.error(`Airtable API error: ${fetchResponse.status} - ${errorBody}`);
                throw new Error(`Airtable API error: ${fetchResponse.status} - ${errorBody}`);
            }
            return fetchResponse.json();
        };

        // Helper function to parse DD.MM.YYYY date strings reliably
        function parseEuropeanDate(dateString) {
            if (!dateString) return null;
            // Try to parse as ISO first (Airtable API often sends YYYY-MM-DD)
            const isoDate = new Date(dateString);
            if (!isNaN(isoDate.getTime())) {
                return isoDate;
            }

            // Fallback to DD.MM.YYYY parsing if ISO parsing fails
            const parts = dateString.split('.');
            if (parts.length === 3) {
                const day = parseInt(parts[0], 10);
                const month = parseInt(parts[1], 10) - 1; // Month is 0-indexed
                const year = parseInt(parts[2], 10);
                const date = new Date(year, month, day);
                // Validate parsed date to prevent issues with invalid day/month combinations
                if (date.getFullYear() === year && date.getMonth() === month && date.getDate() === day) {
                    return date;
                }
            }
            return null; // Invalid date
        }


        // Routing logic based on the path
        if (path === '/') {
            // ===============================================================
            // ================ Daten abrufen (Lese-Endpunkt) ================
            // ===============================================================
            if (request.method !== 'POST') {
                return new Response(JSON.stringify({ error: 'Methode nicht erlaubt. Erwarte POST.' }), {
                    status: 405,
                    headers: { 'Content-Type': 'application/json', ...defaultHeaders }
                });
            }

            try {
                const AIRTABLE_API_KEY = env.AIRTABLE_API_KEY;
                const AIRTABLE_BASE_ID = env.AIRTABLE_BASE_ID;
                if (!AIRTABLE_API_KEY || !AIRTABLE_BASE_ID) {
                    console.error("[Worker ERROR] API Key oder Base ID fehlt.");
                    return new Response(JSON.stringify({ error: 'Serverkonfiguration unvollständig.' }), { status: 500, headers: { 'Content-Type': 'application/json', ...defaultHeaders } });
                }

                const requestBody = await request.json();
                const portalId = requestBody.id;
                if (!portalId) {
                    return new Response(JSON.stringify({ error: 'Portal-ID fehlt im Request Body.' }), { status: 400, headers: { 'Content-Type': 'application/json', ...defaultHeaders } });
                }

                // Datenabrufe von Airtable parallel ausführen
                const filterFormula = `({Portal-ID} = '${portalId}')`;
                const encodedFilter = encodeURIComponent(filterFormula);

                const teilnehmerinnenUrl = `https://api.airtable.com/v0/${AIRTABLE_BASE_ID}/Teilnehmerinnen?filterByFormula=${encodedFilter}&maxRecords=1`;
                const invoicesUrl = `https://api.airtable.com/v0/${AIRTABLE_BASE_ID}/Rechnungen?filterByFormula=${encodedFilter}&sort%5B0%5D%5Bfield%5D=Datum&sort%5B0%5D%5Bdirection%5D=desc`;
                const appointmentsUrl = `https://api.airtable.com/v0/${AIRTABLE_BASE_ID}/Bestätigte Termine?filterByFormula=${encodedFilter}&sort%5B0%5D%5Bfield%5D=Datum&sort%5B0%5D%5Bdirection%5D=asc`;

                const [teilnehmerinnenResponse, invoicesResponse, confirmedAppointmentsResponse] = await Promise.all([
                    fetch(teilnehmerinnenUrl, { headers: { 'Authorization': `Bearer ${AIRTABLE_API_KEY}`, 'Content-Type': 'application/json' } }),
                    fetch(invoicesUrl, { headers: { 'Authorization': `Bearer ${AIRTABLE_API_KEY}`, 'Content-Type': 'application/json' } }),
                    fetch(appointmentsUrl, { headers: { 'Authorization': `Bearer ${AIRTABLE_API_KEY}`, 'Content-Type': 'application/json' } })
                ]);
                
                // Fehlerbehandlung für jede API-Antwort
                if (!teilnehmerinnenResponse.ok) {
                    const errorBody = await teilnehmerinnenResponse.text();
                    console.error(`[Worker ERROR] Fehler beim Abrufen der Teilnehmerinnen-Daten: ${teilnehmerinnenResponse.status} - ${errorBody}`);
                    return new Response(JSON.stringify({ error: 'Fehler beim Abrufen der Teilnehmerinnen-Daten.', details: errorBody }), { status: teilnehmerinnenResponse.status, headers: { 'Content-Type': 'application/json', ...defaultHeaders } });
                }
                const teilnehmerinnenData = await teilnehmerinnenResponse.json();
                if (!teilnehmerinnenData.records || teilnehmerinnenData.records.length === 0) {
                    return new Response(JSON.stringify({ error: 'Teilnehmerin mit dieser Portal-ID nicht gefunden.' }), { status: 404, headers: { 'Content-Type': 'application/json', ...defaultHeaders } });
                }

                const invoicesData = invoicesResponse.ok ? await invoicesResponse.json() : { records: [] };
                const confirmedAppointmentsData = confirmedAppointmentsResponse.ok ? await confirmedAppointmentsResponse.json() : { records: [] };
                
                // Daten aus dem Hauptdatensatz formatieren
                const userRecord = teilnehmerinnenData.records[0].fields;
                
                // Finales Daten-Objekt für die Web-App erstellen
                const appData = {
                    firstName: userRecord["Vorname"] || '',
                    gamificationPoints: userRecord["Gamification Punkte"] !== undefined ? userRecord["Gamification Punkte"] : 0,
                    news: userRecord["Aktuelle News"] || 'Keine neuen Ankündigungen.',
                    // Next appointment logic
                    nextAppointment: confirmedAppointmentsData.records.length > 0 ? (() => {
                        const rawDate = confirmedAppointmentsData.records[0].fields["Datum"];
                        const parsedDate = parseEuropeanDate(rawDate);
                        return parsedDate ? {
                            date: rawDate, // Keep original for ICS generation
                            day: parsedDate.getDate().toString().padStart(2, '0'),
                            month: parsedDate.toLocaleString('de-DE', { month: 'long' }),
                            group: confirmedAppointmentsData.records[0].fields["Gruppe"] || '',
                            time: "19:00 - 20:30 Uhr"
                        } : null;
                    })() : null,
                    resources: JSON.parse(userRecord["Ressourcen JSON"] || '[]'),
                    guthaben: {
                        used: userRecord["Guthaben genutzt"] !== undefined ? userRecord["Guthaben genutzt"] : 0,
                        total: userRecord["Guthaben total"] !== undefined ? userRecord["Guthaben total"] : 0,
                        type: userRecord["Kartentyp"] || 'Keine Karte',
                    },
                    invoices: invoicesData.records.map(record => {
                        const parsedDate = parseEuropeanDate(record.fields["Datum"]);
                        return {
                            "Rechnungsnummer": record.fields["Rechnungsnummer"] || '',
                            "Datum": parsedDate ? parsedDate.toLocaleDateString('de-DE') : '',
                            "Betrag": record.fields["Betrag"] || 0,
                            "Status": record.fields["Status"] || 'Unbekannt',
                            "PDF-URL": record.fields["PDF-URL"] || '#',
                        };
                    }) || [],
                    confirmedAppointments: confirmedAppointmentsData.records.map(record => {
                        const rawDate = record.fields["Datum"];
                        const parsedDate = parseEuropeanDate(rawDate);
                        return parsedDate ? {
                            date: rawDate, // Keep original for ICS generation
                            day: parsedDate.getDate().toString().padStart(2, '0'),
                            month: parsedDate.toLocaleString('de-DE', { month: 'short' }),
                            group: record.fields["Gruppe"] || '',
                            time: "19:00 - 20:30 Uhr"
                        } : null;
                    }).filter(Boolean) || [], // Filter out nulls if parsing failed
                };
                
                console.log("[Worker] Final formatierte App-Daten an den Client gesendet:", JSON.stringify(appData));
                return new Response(JSON.stringify(appData), { headers: { 'Content-Type': 'application/json', 'Cache-Control': 'no-store', ...defaultHeaders } });

            } catch (e) {
                console.error('[Worker FATAL ERROR] Absturz:', e.stack || e);
                return new Response(JSON.stringify({ error: 'Worker-Absturz.', details: e.message }), { status: 500, headers: { 'Content-Type': 'application/json', ...defaultHeaders } });
            }

        } else if (path === '/set-availability') {
            // ===============================================================
            // ================ Verfügbarkeit speichern (Schreib-Endpunkt) ================
            // ===============================================================
            if (request.method !== 'POST') {
                return new Response(JSON.stringify({ error: 'Methode nicht erlaubt. Erwarte POST.' }), {
                    status: 405,
                    headers: { 'Content-Type': 'application/json', ...defaultHeaders }
                });
            }

            try {
                const AIRTABLE_API_KEY = env.AIRTABLE_API_KEY;
                const AIRTABLE_BASE_ID = env.AIRTABLE_BASE_ID;
                if (!AIRTABLE_API_KEY || !AIRTABLE_BASE_ID) {
                    return new Response(JSON.stringify({ error: 'Serverkonfiguration unvollständig.' }), { status: 500, headers: { 'Content-Type': 'application/json', ...defaultHeaders } });
                }

                const requestBody = await request.json();
                const { id: portalId, availableDates } = requestBody;

                if (!portalId || !Array.isArray(availableDates)) {
                    return new Response(JSON.stringify({ error: 'Ungültiger Request Body.' }), { status: 400, headers: { 'Content-Type': 'application/json', ...defaultHeaders } });
                }

                // 1. Finde den Teilnehmer-Datensatz anhand der Portal-ID
                const filterFormula = `({Portal-ID} = '${portalId}')`;
                const encodedFilter = encodeURIComponent(filterFormula);
                const teilnehmerinnenUrl = `https://api.airtable.com/v0/${AIRTABLE_BASE_ID}/Teilnehmerinnen?filterByFormula=${encodedFilter}&maxRecords=1`;
                const searchResult = await fetchAirtable(teilnehmerinnenUrl);

                if (!searchResult.records || searchResult.records.length === 0) {
                    return new Response(JSON.stringify({ error: 'Teilnehmerin nicht gefunden.' }), { status: 404, headers: { 'Content-Type': 'application/json', ...defaultHeaders } });
                }

                const recordIdToUpdate = searchResult.records[0].id;

                // 2. Erstelle das JSON-Objekt für die Aktualisierung
                const updatePayload = {
                    records: [{
                        id: recordIdToUpdate,
                        fields: {
                            "Verfügbarkeit Oktober": availableDates
                        }
                    }]
                };

                // 3. Sende den Update-Request an Airtable
                const updateUrl = `https://api.airtable.com/v0/${AIRTABLE_BASE_ID}/Teilnehmerinnen`;
                await fetchAirtable(updateUrl, {
                    method: 'PATCH',
                    headers: {
                        'Authorization': `Bearer ${AIRTABLE_API_KEY}`,
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(updatePayload)
                });

                console.log(`[Worker] Verfügbarkeit für Portal-ID ${portalId} erfolgreich aktualisiert.`);
                return new Response(JSON.stringify({ success: true, message: "Verfügbarkeit wurde aktualisiert." }), {
                    status: 200,
                    headers: { 'Content-Type': 'application/json', ...defaultHeaders }
                });

            } catch (e) {
                console.error('[Worker ERROR] Fehler beim Speichern der Verfügbarkeit:', e.message);
                return new Response(JSON.stringify({ error: 'Interner Serverfehler beim Speichern der Verfügbarkeit.', details: e.message }), {
                    status: 500,
                    headers: { 'Content-Type': 'application/json', ...defaultHeaders }
                });
            }

        } else {
            // Unbekannter Endpunkt
            return new Response(JSON.stringify({ error: 'Nicht gefunden.' }), {
                status: 404,
                headers: { 'Content-Type': 'application/json', ...defaultHeaders }
            });
        }
    },
};
