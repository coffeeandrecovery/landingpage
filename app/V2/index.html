/**
 * Cloudflare Worker für die Integration mit Airtable.
 *
 * Hauptfunktionen:
 * 1) GET/POST '/'        -> App-Daten lesen (POST erwartet { id })
 * 2) POST '/set-availability' -> Verfügbarkeit speichern
 * 3) GET  '/debug-airtable'   -> rohe Airtable-Daten lesen (Debug)
 * 4) GET  '/debug-write-availability' -> Schreibtest (Debug)
 *
 * Erforderliche Secrets:
 * - AIRTABLE_API_KEY
 * - AIRTABLE_BASE_ID
 */

export default {
  async fetch(request, env, ctx) {
    console.log(`[Worker Start] Anfrage: ${request.method} ${request.url}`);

    const url = new URL(request.url);
    const path = url.pathname;

    // ---- Dynamische CORS-Allowlist (ggf. erweitern) ----
    const allowedOrigins = new Set([
      'https://www.burnouthilfe.org',
      // 'https://deine-preview-domain.xyz', // optional
    ]);
    const requestOrigin = request.headers.get('Origin');
    const corsOrigin = allowedOrigins.has(requestOrigin)
      ? requestOrigin
      : 'https://www.burnouthilfe.org';

    const defaultHeaders = {
      'Access-Control-Allow-Origin': corsOrigin,
      'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization',
      'Access-Control-Max-Age': '86400',
      'Vary': 'Origin',
    };

    if (request.method === 'OPTIONS') {
      console.log('[Worker] OPTIONS (CORS Preflight).');
      return new Response(null, { status: 204, headers: defaultHeaders });
    }

    // ---- Helper: robuste Airtable-Fetch-Funktion ----
    const fetchAirtable = async (endpoint, options = {}) => {
      try {
        const res = await fetch(endpoint, options);
        if (!res.ok) {
          const errBody = await res.text();
          console.error(`Airtable API error: ${res.status} - ${errBody}`);
          throw new Error(`Airtable API error: ${res.status} - ${errBody}`);
        }
        return await res.json();
      } catch (error) {
        console.error(`Error during fetchAirtable to ${endpoint}: ${error.message}`);
        throw error;
      }
    };

    // ---- Helper: Datum DD.MM.YYYY oder YYYY-MM-DD sicher parsen ----
    function parseEuropeanDate(dateString) {
      if (!dateString) return null;

      // ISO 8601 (YYYY-MM-DD)
      const isoDate = new Date(dateString);
      if (!isNaN(isoDate.getTime()) && dateString.includes('-')) {
        return isoDate;
      }

      // DD.MM.YYYY
      const parts = dateString.split('.');
      if (parts.length === 3) {
        const day = parseInt(parts[0], 10);
        const month = parseInt(parts[1], 10) - 1;
        const year = parseInt(parts[2], 10);
        const d = new Date(year, month, day);
        if (d.getFullYear() === year && d.getMonth() === month && d.getDate() === day) {
          return d;
        }
      }
      return null;
    }

    // =====================================================================
    // ========================= ROUTING ===================================
    // =====================================================================

    if (path === '/') {
      // ===================== Daten lesen ======================
      if (request.method !== 'POST') {
        return new Response(JSON.stringify({ error: 'Methode nicht erlaubt. Erwarte POST.' }), {
          status: 405,
          headers: { 'Content-Type': 'application/json', ...defaultHeaders },
        });
      }

      try {
        const AIRTABLE_API_KEY = env.AIRTABLE_API_KEY;
        const AIRTABLE_BASE_ID = env.AIRTABLE_BASE_ID;
        if (!AIRTABLE_API_KEY || !AIRTABLE_BASE_ID) {
          console.error('[Worker ERROR] API Key oder Base ID fehlt.');
          return new Response(JSON.stringify({ error: 'Serverkonfiguration unvollständig.' }), {
            status: 500,
            headers: { 'Content-Type': 'application/json', ...defaultHeaders },
          });
        }

        const body = await request.json();
        const portalId = body.id;
        if (!portalId) {
          return new Response(JSON.stringify({ error: 'Portal-ID fehlt im Request Body.' }), {
            status: 400,
            headers: { 'Content-Type': 'application/json', ...defaultHeaders },
          });
        }

        const filterFormula = `({Portal-ID} = '${portalId}')`;
        const encodedFilter = encodeURIComponent(filterFormula);

        // 1) Teilnehmerinnen-Daten
        const teilnehmerinnenUrl = `https://api.airtable.com/v0/${AIRTABLE_BASE_ID}/Teilnehmerinnen?filterByFormula=${encodedFilter}&maxRecords=1`;
        const teilnehmerinnenData = await fetchAirtable(teilnehmerinnenUrl, {
          headers: {
            Authorization: `Bearer ${AIRTABLE_API_KEY}`,
            'Content-Type': 'application/json',
          },
        });

        if (!teilnehmerinnenData.records || teilnehmerinnenData.records.length === 0) {
          return new Response(JSON.stringify({ error: 'Teilnehmerin mit dieser Portal-ID nicht gefunden.' }), {
            status: 404,
            headers: { 'Content-Type': 'application/json', ...defaultHeaders },
          });
        }

        const userRecord = teilnehmerinnenData.records[0].fields;
        const userRecordId = teilnehmerinnenData.records[0].id;

        // 2) Rechnungen zur Teilnehmerin
        let invoicesData = { records: [] };
        try {
          const invoicesFilterFormula = `SEARCH('${userRecordId}', {Teilnehmerin})`;
          const encodedInvoicesFilter = encodeURIComponent(invoicesFilterFormula);
          const invoicesUrl = `https://api.airtable.com/v0/${AIRTABLE_BASE_ID}/Rechnungen?filterByFormula=${encodedInvoicesFilter}&sort%5B0%5D%5Bfield%5D=Datum&sort%5B0%5D%5Bdirection%5D=desc`;
          invoicesData = await fetchAirtable(invoicesUrl, {
            headers: {
              Authorization: `Bearer ${AIRTABLE_API_KEY}`,
              'Content-Type': 'application/json',
            },
          });
        } catch (e) {
          console.warn(`[Worker WARN] Fehler beim Abrufen Rechnungen: ${e.message}`);
        }

        // 3) Bestätigte Termine über verknüpfte IDs
        let confirmedAppointments = [];
        const linkedAppointmentIds = userRecord['Bestätigte Termine'] || [];
        if (linkedAppointmentIds.length > 0) {
          const appointmentFilterFormula = linkedAppointmentIds
            .map((id) => `RECORD_ID() = '${id}'`)
            .join(',');
          const encodedAppointmentFilter = encodeURIComponent(`OR(${appointmentFilterFormula})`);
          const appointmentsUrl = `https://api.airtable.com/v0/${AIRTABLE_BASE_ID}/Bestätigte Termine?filterByFormula=${encodedAppointmentFilter}&sort%5B0%5D%5Bfield%5D=Datum&sort%5B0%5D%5Bdirection%5D=asc`;

          try {
            const fetchedAppointments = await fetchAirtable(appointmentsUrl, {
              headers: {
                Authorization: `Bearer ${AIRTABLE_API_KEY}`,
                'Content-Type': 'application/json',
              },
            });
            confirmedAppointments = fetchedAppointments.records || [];
          } catch (e) {
            console.warn(`[Worker WARN] Fehler beim Abrufen der Termine: ${e.message}`);
          }
        }

        // 4) App-Response bauen
        const appData = {
          firstName: userRecord['Vorname'] || '',
          gamificationPoints:
            userRecord['Gamification Punkte'] !== undefined ? userRecord['Gamification Punkte'] : 0,
          news: userRecord['Aktuelle News'] || 'Keine neuen Ankündigungen.',

          nextAppointment:
            confirmedAppointments.length > 0
              ? (() => {
                  const firstAppointment = confirmedAppointments[0].fields;
                  const rawDate = firstAppointment['Datum'];
                  const parsedDate = parseEuropeanDate(rawDate);
                  const groupName =
                    firstAppointment['Gruppe'] && firstAppointment['Gruppe'].length > 0
                      ? firstAppointment['Gruppe'][0]
                      : '';
                  return parsedDate
                    ? {
                        date: rawDate,
                        day: parsedDate.getDate().toString().padStart(2, '0'),
                        month: parsedDate.toLocaleString('de-DE', { month: 'long' }),
                        group: groupName,
                        time: '19:00 - 20:30 Uhr',
                      }
                    : null;
                })()
              : null,

          resources: JSON.parse(userRecord['Ressourcen JSON'] || '[]'),

          guthaben: {
            used: userRecord['Guthaben genutzt'] !== undefined ? userRecord['Guthaben genutzt'] : 0,
            total: userRecord['Guthaben total'] !== undefined ? userRecord['Guthaben total'] : 0,
            type:
              userRecord['Kartentyp'] && userRecord['Kartentyp'].length > 0
                ? userRecord['Kartentyp'][0]
                : 'Keine Karte',
          },

          invoices:
            (invoicesData.records || []).map((record) => {
              const parsedDate = parseEuropeanDate(record.fields['Datum']);
              return {
                Rechnungsnummer: record.fields['Rechnungsnummer'] || '',
                Datum: parsedDate ? parsedDate.toLocaleString('de-DE', { month: 'long' }) : '',
                Betrag: record.fields['Betrag'] || 0,
                Status: record.fields['Status'] || 'Unbekannt',
                'PDF-URL': record.fields['PDF-URL'] || '#',
              };
            }) || [],

          confirmedAppointments:
            (confirmedAppointments || [])
              .map((record) => {
                const rawDate = record.fields['Datum'];
                const parsedDate = parseEuropeanDate(rawDate);
                const groupName =
                  record.fields['Gruppe'] && record.fields['Gruppe'].length > 0
                    ? record.fields['Gruppe'][0]
                    : '';
                return parsedDate
                  ? {
                      date: rawDate,
                      day: parsedDate.getDate().toString().padStart(2, '0'),
                      month: parsedDate.toLocaleString('de-DE', { month: 'short' }),
                      group: groupName,
                      time: '19:00 - 20:30 Uhr',
                    }
                  : null;
              })
              .filter(Boolean) || [],
        };

        console.log('[Worker] Sende App-Daten:', JSON.stringify(appData));
        return new Response(JSON.stringify(appData), {
          headers: {
            'Content-Type': 'application/json',
            'Cache-Control': 'no-store',
            ...defaultHeaders,
          },
        });
      } catch (e) {
        console.error('[Worker FATAL ERROR] Absturz:', e.stack || e);
        return new Response(JSON.stringify({ error: 'Worker-Absturz.', details: e.message }), {
          status: 500,
          headers: { 'Content-Type': 'application/json', ...defaultHeaders },
        });
      }
    }

    else if (path === '/set-availability') {
      // ===================== Verfügbarkeit schreiben ======================
      if (request.method !== 'POST') {
        return new Response(JSON.stringify({ error: 'Methode nicht erlaubt. Erwarte POST.' }), {
          status: 405,
          headers: { 'Content-Type': 'application/json', ...defaultHeaders },
        });
      }

      try {
        const AIRTABLE_API_KEY = env.AIRTABLE_API_KEY;
        const AIRTABLE_BASE_ID = env.AIRTABLE_BASE_ID;
        if (!AIRTABLE_API_KEY || !AIRTABLE_BASE_ID) {
          return new Response(JSON.stringify({ error: 'Serverkonfiguration unvollständig.' }), {
            status: 500,
            headers: { 'Content-Type': 'application/json', ...defaultHeaders },
          });
        }

        const requestBody = await request.json();
        const { id: portalId, availableDates } = requestBody;

        if (!portalId || !Array.isArray(availableDates)) {
          return new Response(JSON.stringify({ error: 'Ungültiger Request Body.' }), {
            status: 400,
            headers: { 'Content-Type': 'application/json', ...defaultHeaders },
          });
        }

        // 1) Teilnehmerin über Portal-ID suchen (JETZT MIT AUTH HEADER!)
        const filterFormula = `({Portal-ID} = '${portalId}')`;
        const encodedFilter = encodeURIComponent(filterFormula);
        const teilnehmerinnenUrl = `https://api.airtable.com/v0/${AIRTABLE_BASE_ID}/Teilnehmerinnen?filterByFormula=${encodedFilter}&maxRecords=1`;
        const searchResult = await fetchAirtable(teilnehmerinnenUrl, {
          headers: {
            Authorization: `Bearer ${AIRTABLE_API_KEY}`,
            'Content-Type': 'application/json',
          },
        });

        if (!searchResult.records || searchResult.records.length === 0) {
          return new Response(JSON.stringify({ error: 'Teilnehmerin nicht gefunden.' }), {
            status: 404,
            headers: { 'Content-Type': 'application/json', ...defaultHeaders },
          });
        }

        const recordIdToUpdate = searchResult.records[0].id;

        // 2) Payload für Update
        const updatePayload = {
          records: [
            {
              id: recordIdToUpdate,
              fields: {
                'Verfügbarkeit Oktober': availableDates,
              },
            },
          ],
        };

        // 3) PATCH an Airtable
        const updateUrl = `https://api.airtable.com/v0/${AIRTABLE_BASE_ID}/Teilnehmerinnen`;
        await fetchAirtable(updateUrl, {
          method: 'PATCH',
          headers: {
            Authorization: `Bearer ${AIRTABLE_API_KEY}`,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(updatePayload),
        });

        console.log(`[Worker] Verfügbarkeit für Portal-ID ${portalId} aktualisiert.`);
        return new Response(JSON.stringify({ success: true, message: 'Verfügbarkeit wurde aktualisiert.' }), {
          status: 200,
          headers: { 'Content-Type': 'application/json', ...defaultHeaders },
        });
      } catch (e) {
        console.error('[Worker ERROR] Fehler beim Speichern der Verfügbarkeit:', e.message);
        return new Response(
          JSON.stringify({
            error: 'Interner Serverfehler beim Speichern der Verfügbarkeit.',
            details: e.message,
          }),
          {
            status: 500,
            headers: { 'Content-Type': 'application/json', ...defaultHeaders },
          }
        );
      }
    }

    else if (path === '/debug-airtable') {
      // ===================== Debug Read ======================
      if (request.method !== 'GET') {
        return new Response(JSON.stringify({ error: 'Methode nicht erlaubt. Erwarte GET.' }), {
          status: 405,
          headers: { 'Content-Type': 'application/json', ...defaultHeaders },
        });
      }

      try {
        const AIRTABLE_API_KEY = env.AIRTABLE_API_KEY;
        const AIRTABLE_BASE_ID = env.AIRTABLE_BASE_ID;
        if (!AIRTABLE_API_KEY || !AIRTABLE_BASE_ID) {
          return new Response(JSON.stringify({ error: 'Serverkonfiguration unvollständig.' }), {
            status: 500,
            headers: { 'Content-Type': 'application/json', ...defaultHeaders },
          });
        }

        const tableName = url.searchParams.get('table');
        const portalId = url.searchParams.get('id');
        const recordId = url.searchParams.get('recordId');

        if (!tableName) {
          return new Response(JSON.stringify({ error: 'Tabellenname (table) fehlt.' }), {
            status: 400,
            headers: { 'Content-Type': 'application/json', ...defaultHeaders },
          });
        }

        let airtableUrl = `https://api.airtable.com/v0/${AIRTABLE_BASE_ID}/${encodeURIComponent(tableName)}`;
        if (recordId) {
          airtableUrl += `/${encodeURIComponent(recordId)}`;
        } else if (portalId) {
          const filterFormula = `({Portal-ID} = '${portalId}')`;
          const encodedFilter = encodeURIComponent(filterFormula);
          airtableUrl += `?filterByFormula=${encodedFilter}&maxRecords=1`;
        } else {
          airtableUrl += `?maxRecords=5`;
        }

        console.log(`[Worker Debug Read] Airtable URL: ${airtableUrl}`);
        const rawAirtableData = await fetchAirtable(airtableUrl, {
          headers: {
            Authorization: `Bearer ${AIRTABLE_API_KEY}`,
            'Content-Type': 'application/json',
          },
        });

        return new Response(JSON.stringify(rawAirtableData, null, 2), {
          status: 200,
          headers: { 'Content-Type': 'application/json', ...defaultHeaders },
        });
      } catch (e) {
        console.error('[Worker DEBUG Read ERROR] Fehler:', e.message);
        return new Response(
          JSON.stringify({ error: 'Fehler beim Abrufen roher Airtable-Daten.', details: e.message }),
          { status: 500, headers: { 'Content-Type': 'application/json', ...defaultHeaders } }
        );
      }
    }

    else if (path === '/debug-write-availability') {
      // ===================== Debug Write ======================
      if (request.method !== 'GET') {
        return new Response(
          JSON.stringify({ error: 'Methode nicht erlaubt. Erwarte GET für Debug-Schreibtest.' }),
          { status: 405, headers: { 'Content-Type': 'application/json', ...defaultHeaders } }
        );
      }

      try {
        const AIRTABLE_API_KEY = env.AIRTABLE_API_KEY;
        const AIRTABLE_BASE_ID = env.AIRTABLE_BASE_ID;
        if (!AIRTABLE_API_KEY || !AIRTABLE_BASE_ID) {
          return new Response(JSON.stringify({ error: 'Serverkonfiguration unvollständig.' }), {
            status: 500,
            headers: { 'Content-Type': 'application/json', ...defaultHeaders },
          });
        }

        const portalId = url.searchParams.get('id');
        if (!portalId) {
          return new Response(JSON.stringify({ error: 'Portal-ID fehlt im Query-Parameter.' }), {
            status: 400,
            headers: { 'Content-Type': 'application/json', ...defaultHeaders },
          });
        }

        // 1) Teilnehmerin über Portal-ID suchen (JETZT MIT AUTH HEADER!)
        const filterFormula = `({Portal-ID} = '${portalId}')`;
        const encodedFilter = encodeURIComponent(filterFormula);
        const teilnehmerinnenUrl = `https://api.airtable.com/v0/${AIRTABLE_BASE_ID}/Teilnehmerinnen?filterByFormula=${encodedFilter}&maxRecords=1`;
        const searchResult = await fetchAirtable(teilnehmerinnenUrl, {
          headers: {
            Authorization: `Bearer ${AIRTABLE_API_KEY}`,
            'Content-Type': 'application/json',
          },
        });

        if (!searchResult.records || searchResult.records.length === 0) {
          return new Response(JSON.stringify({ error: 'Teilnehmerin nicht gefunden.' }), {
            status: 404,
            headers: { 'Content-Type': 'application/json', ...defaultHeaders },
          });
        }

        const recordIdToUpdate = searchResult.records[0].id;
        const dummyAvailableDates = [`${new Date().toISOString().split('T')[0]}_DEBUG`];

        const updatePayload = {
          records: [
            {
              id: recordIdToUpdate,
              fields: { 'Verfügbarkeit Oktober': dummyAvailableDates },
            },
          ],
        };

        const updateUrl = `https://api.airtable.com/v0/${AIRTABLE_BASE_ID}/Teilnehmerinnen`;
        console.log(`[Worker Debug Write] PATCH -> ${updateUrl}`);
        console.log(`[Worker Debug Write] Payload: ${JSON.stringify(updatePayload)}`);

        // Hier nutzen wir absichtlich raw fetch, um Fehlkörper 1:1 zu sehen
        const airtableWriteResponse = await fetch(updateUrl, {
          method: 'PATCH',
          headers: {
            Authorization: `Bearer ${AIRTABLE_API_KEY}`,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(updatePayload),
        });

        if (!airtableWriteResponse.ok) {
          const errorBody = await airtableWriteResponse.text();
          console.error(`[Worker Debug Write ERROR] ${airtableWriteResponse.status} - ${errorBody}`);
          let details;
          try {
            details = JSON.parse(errorBody);
          } catch {
            details = errorBody;
          }
          return new Response(
            JSON.stringify(
              {
                status: 'error',
                message: 'Schreibtest fehlgeschlagen.',
                airtableStatus: airtableWriteResponse.status,
                airtableErrorDetails: details,
              },
              null,
              2
            ),
            { status: 500, headers: { 'Content-Type': 'application/json', ...defaultHeaders } }
          );
        }

        const successData = await airtableWriteResponse.json();
        console.log(`[Worker Debug Write] Erfolg.`);
        return new Response(
          JSON.stringify(
            {
              status: 'success',
              message: 'Schreibtest erfolgreich. Airtable-Datensatz wurde aktualisiert.',
              airtableResponse: successData,
            },
            null,
            2
          ),
          { status: 200, headers: { 'Content-Type': 'application/json', ...defaultHeaders } }
        );
      } catch (e) {
        console.error('[Worker DEBUG Write FATAL ERROR] Absturz:', e.stack || e);
        return new Response(
          JSON.stringify({ status: 'error', message: 'Interner Serverfehler beim Schreibtest.', details: e.message }, null, 2),
          { status: 500, headers: { 'Content-Type': 'application/json', ...defaultHeaders } }
        );
      }
    }

    // ===================== 404 ======================
    return new Response(JSON.stringify({ error: 'Nicht gefunden.' }), {
      status: 404,
      headers: { 'Content-Type': 'application/json', ...defaultHeaders },
    });
  },
};